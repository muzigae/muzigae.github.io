---
layout: post
category: [PS, BOJ, P5]
title:  "BOJ 1353 합과 곱"
date:   2022-01-26 13:36:08 +0900
author: muzigae
use_math: true
---
[BOJ 1353 합과 곱](https://www.acmicpc.net/problem/1353)

{% highlight C++ linenos %}
#include <iostream>
#include <cmath>
using namespace std;

int s, p;
double f(int x) {
	return pow((double)s / x, x);
}

int main() {
	ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
	cin >> s >> p;
	if (s == p) return !(cout << 1);
	int n = 2;
	while (1) {
		if (f(n) >= p) return !(cout << n);
		else if (f(n) > f(n + 1)) return !(cout << -1);
		n++;
	}
	return 0;
}
{% endhighlight %}

산술 평균과 기하 평균을 이용한다.<br>
음이 아닌 실수열 $a_1, a_2, ···, a_n$이 주어져 있을 때, 산술-기하 평균 부등식은 다음과 같다.<br>
@@\frac{a_1+a_2+···+a_n}{n} \ge \sqrt[n]{a_1a_2···a_n}@@
문제에서 주어진 S와 P는 음이 아닌 어떤 실수열, 더하여 P가 자연수이므로 양수열의 합과 곱에 해당한다.
@@S=a_1+a_2+···+a_n@@
@@P=a_1a_2···a_n@@
@@\frac{S}{n} \ge \sqrt[n]{P}@@
그러므로 위와 같이 S와 P를 부등식에 적용할 수 있다. 여기서 $n$이 바로 리스트의 크기가 되며,<br>
결론적으로 위 부등식을 만족시키는 $n$의 최솟값을 구하면 된다.<br>
$n$을 $x$라고 하고, 부등식을 다음과 같이 조금 바꿔보자.
@@(\frac{S}{x})^x \ge P@@
함수로 생각하여 그래프를 그려보면 더 직관적이다.
@@f(x)=(\frac{S}{x})^x@@
@@f'(x)=(\frac{S}{x})^{x}(\ln \frac{S}{x}-1)@@
$f(x)$는 $x=\frac{S}{e}$에서 극댓값을 가지는 함수이다.<br>
예시로 $S=5$일 때 $f(x)$의 그래프와 $P=4$일 때 $y=P$를 그려보면 다음과 같은 그림이 나온다.<br><br>
<img width = 500 src = "/assets/img/post_img/BOJ1353_plot.png"/><br><br>
빨간 그래프가 파란 그래프보다 더 큰 $y$값을 가지도록 하는 $x$값을 찾으면 된다.<br>
한 가지 주의할 것은 $S \ge P$일 경우 $x=1$일 때 위 부등식이 항상 성립하지만, $x=1$은 본질적으로 수열의 길이가 1이라는 뜻이고 합과 곱이 다를 수 없다는 점이다. 따라서 $S=P$인 경우에만 $x=1$이 수열 길이의 최솟값이 되며, 다른 모든 경우는 적어도 길이 2부터 시작하게 된다.

{% highlight C++ %}
// f(x)에 해당하는 함수 구현
int s, p;
double f(int x) {
	return pow((double)s / x, x);
}

// Main
cin >> s >> p;
if (s == p) return !(cout << 1); // S = P인 경우 1 출력 후 종료
int n = 2; // S != P 길이 2부터 탐색

while (1) {
	// loop를 돌며 f(x)가 P보다 큰 y값을 가지는 자연수 n을 찾을 경우 종료
	if (f(n) >= p) return !(cout << n);

	// x가 자연수일 때 f(x)의 최댓값이 P를 넘지 못하므로 종료
	else if (f(n) > f(n + 1)) return !(cout << -1);
	n++;
}
{% endhighlight %}