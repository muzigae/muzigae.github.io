---
layout: post
category: [PS, BOJ, P5]
title:  "BOJ 1028 다이아몬드 광산"
date:   2022-08-14 13:03:35 +0900
author: muzigae
use_math: true
---
[BOJ 1028 다이아몬드 광산](https://www.acmicpc.net/problem/1028)

{% highlight C++ linenos %}
#include <iostream>
using namespace std;

int v[800][800], lu[800][800], ld[800][800], ru[800][800], rd[800][800];

int main() {
	ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
	int r, c, res = 0; cin >> r >> c;
	for (int i = 1; i <= r; i++) {
		string s; cin >> s;
		for (int j = 1; j <= c; j++) v[i][j] = s[j - 1] - '0';
	}

	for (int i = 1; i <= r; i++) for (int j = 1; j <= c; j++) {
		if (v[i][j]) {
			lu[i][j] = lu[i - 1][j - 1] + 1;
			ru[i][j] = ru[i - 1][j + 1] + 1;
		}
		if (v[r + 1 - i][j]) {
			ld[r + 1 - i][j] = ld[r + 1 - i + 1][j - 1] + 1;
			rd[r + 1 - i][j] = rd[r + 1 - i + 1][j + 1] + 1;
		}
	}

	for (int i = 1; i <= r; i++) for (int j = 1; j <= c; j++) {
		int L = min(ld[i][j], rd[i][j]);
		for (int k = 1; k <= L; k++) {
			int x = i + 2 * (k - 1);
			if (k <= min(lu[x][j], ru[x][j])) res = max(res, k);
		}
	} cout << res;
	return 0;
}
{% endhighlight %}
풀이는 간단하게 2단계로 이루어진다.<br>
1. 위치마다 대각 4방향으로 각각 연속하는 1의 개수를 저장한다.
2. 광산을 탐색하면서 해당 지점을 마름모의 한 꼭짓점이라 할 때, 반대편 꼭짓점에서도 같은 크기의 마름모를 만들 수 있는지 확인한다.
<br><br>

{% highlight C++ %}
// DP

for (int i = 1; i <= r; i++) for (int j = 1; j <= c; j++) {
	if (v[i][j]) { // Top-down
		lu[i][j] = lu[i - 1][j - 1] + 1; // 왼쪽 위
		ru[i][j] = ru[i - 1][j + 1] + 1; // 오른쪽 위
	}
	if (v[r + 1 - i][j]) { // Bottom-up
		ld[r + 1 - i][j] = ld[r + 1 - i + 1][j - 1] + 1; // 왼쪽 아래
		rd[r + 1 - i][j] = rd[r + 1 - i + 1][j + 1] + 1; // 오른쪽 아래
	}
}
{% endhighlight %}
대각 방향으로 연속하는 1의 개수를 구하는 과정에서 DP를 이용한다.<br>
위쪽 두 방향은 위에서 아래로 계산하고, 아래쪽 두 방향은 아래에서 위로 계산한다.
<br><br>

{% highlight C++ %}
// Upper vertex

for (int i = 1; i <= r; i++) for (int j = 1; j <= c; j++) {
	int L = min(ld[i][j], rd[i][j]); // 최대 길이
	for (int k = 1; k <= L; k++) {
		int x = i + 2 * (k - 1); // 반대편 꼭짓점
		if (k <= min(lu[x][j], ru[x][j])) res = max(res, k);
	}
}
{% endhighlight %}
탐색 과정에서 해당 지점을 마름모의 어떤 꼭짓점으로 정하든 상관없다. 위 코드에서는 위쪽 꼭짓점을 기준으로 하였다.<br>
$(i, j)$가 마름모의 위쪽 꼭짓점이라면, 만들 수 있는 마름모의 최대 크기는 $ld[i][j], rd[i][j]$의 최솟값이다.<br><br>
반대편 꼭짓점은 아래쪽 꼭짓점이 되고 마름모의 크기가 $k$라면 좌표는 $(i+2(k-1), j)$이다.<br>
$x=i+2(k-1)$이라 하면, 여기서 만들 수 있는 마름모의 최대 크기는 $lu[x][j], ru[x][j]$의 최솟값이 된다.<br>
$1$부터 $L$까지 반복문을 돌면서 만들 수 있는 마름모의 최대 크기를 구해주면 끝난다.<br>

<br>
다른 꼭짓점을 기준으로 해도 결과는 변하지 않는다.<br>
만약 왼쪽 꼭짓점을 기준으로 한다면, 반대편 꼭짓점은 $(i, j+2(k-1)$이고 다음과 같이 코드를 작성할 수 있다.
{% highlight C++ %}
// Left vertex

for (int i = 1; i <= r; i++) for (int j = 1; j <= c; j++) {
	int L = min(ru[i][j], rd[i][j]);
	for (int k = 1; k <= L; k++) {
		int x = j + 2 * (k - 1); // 반대편 꼭짓점
		if (k <= min(lu[i][x], ld[i][x])) res = max(res, k);
	}
}
{% endhighlight %}
반대편 꼭짓점과 $min$을 계산하는 배열만 잘 선택해주면 4가지 방법 모두 풀이가 가능하다.