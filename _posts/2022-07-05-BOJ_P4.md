---
layout: post
category: [PS, BOJ, P4]
title:  "BOJ 1109 섬"
date:   2022-07-05 20:47:37 +0900
author: muzigae
use_math: true
---
[BOJ 1109 섬](https://www.acmicpc.net/problem/1109)

{% highlight C++ linenos %}
#include <iostream>
#include <queue>
#include <string>
using namespace std;
using vi = vector<int>;
vector<vi> d4 = { {1, 0}, {0, 1}, {-1, 0}, {0, -1} };
vector<vi> d8 = { {1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1} };

int main() {
	ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
	int r, c; cin >> r >> c;
	vector<vi> v(r, vi(c)), check(r, vi(c, 0));
	for (int i = 0; i < r; i++) {
		string s; cin >> s;
		for (int j = 0; j < c; j++) {
			v[i][j] = s[j];
			if (s[j] == '.') {
				check[i][j] = 1;
				v[i][j] = 1000;
			}
		}
	}

	int cnt = 0; vector<vi> isl;
	for (int i = 0; i < r; i++) {
		for (int j = 0; j < c; j++) {
			if (check[i][j]) continue;
			check[i][j] = 1; isl.push_back({ i, j });

			queue<vi> Q; Q.push({ i, j });
			while (!Q.empty()) {
				int x = Q.front()[0], y = Q.front()[1]; Q.pop();
				v[x][y] = cnt;

				for (auto d : d8) {
					int u = x + d[0], w = y + d[1];
					if (u < 0 || u >= r || w < 0 || w >= c) continue;
					if (check[u][w]) continue;
					check[u][w] = 1; Q.push({ u, w });
				}
			} cnt++;
		}
	} if (cnt == 0) return !(cout << -1);
	
	vi out(cnt, -1);
	for (int i = 0; i < cnt; i++) {
		queue<vi> Q; Q.push({ isl[i][0], isl[i][1] });
		vector<vi> visit = v; bool sea = false;

		int idx = v[isl[i][0]][isl[i][1]];
		while (!Q.empty() && !sea) {
			int x = Q.front()[0], y = Q.front()[1]; Q.pop();
			for (auto d : d4) {
				int u = x + d[0], w = y + d[1];
				if (u < 0 || u >= r || w < 0 || w >= c) {
					sea = true; break;
				}
				if (visit[u][w] != 1000) {
					if (v[u][w] == 1000) continue;
					if (v[u][w] < idx) idx = v[u][w];
					continue;
				}
				visit[u][w] = 1001; Q.push({ u, w });
			}
		} if (!sea) out[i] = idx;
	}

	vi h(cnt, 0); int max_h = 0;
	for (int i = 0; i < cnt; i++) {
		int l = 0, j = i;
		while (out[j] != -1) {
			j = out[j]; l++;
			if (h[j] < l) h[j] = l;
			max_h = max(max_h, l);
		}
	}

	vi res(max_h + 1, 0);
	for (auto i : h) res[i] += 1;
	for (auto i : res) cout << i << " ";
	return 0;
}
{% endhighlight %}

그래프 탐색 문제다. 너비 우선 탐색을 통해 풀 수 있다.<br>
먼저, 풀이의 흐름을 만들어보자.<br>