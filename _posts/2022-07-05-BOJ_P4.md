---
layout: post
category: [PS, BOJ, P4]
title:  "BOJ 1109 섬"
date:   2022-07-05 20:47:37 +0900
author: muzigae
use_math: true
---
[BOJ 1109 섬](https://www.acmicpc.net/problem/1109)

{% highlight C++ linenos %}
#include <iostream>
#include <queue>
#include <string>
using namespace std;
using vi = vector<int>;
vector<vi> d4 = { {1, 0}, {0, 1}, {-1, 0}, {0, -1} };
vector<vi> d8 = { {1, 0}, {1, 1}, {0, 1}, {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}, {1, -1} };

int main() {
	ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
	int r, c; cin >> r >> c;
	vector<vi> v(r, vi(c)), check(r, vi(c, 0));
	for (int i = 0; i < r; i++) {
		string s; cin >> s;
		for (int j = 0; j < c; j++) {
			v[i][j] = s[j];
			if (s[j] == '.') {
				check[i][j] = 1;
				v[i][j] = 1000;
			}
		}
	}

	int cnt = 0; vector<vi> isl;
	for (int i = 0; i < r; i++) {
		for (int j = 0; j < c; j++) {
			if (check[i][j]) continue;
			check[i][j] = 1; isl.push_back({ i, j });

			queue<vi> Q; Q.push({ i, j });
			while (!Q.empty()) {
				int x = Q.front()[0], y = Q.front()[1]; Q.pop();
				v[x][y] = cnt;

				for (auto d : d8) {
					int u = x + d[0], w = y + d[1];
					if (u < 0 || u >= r || w < 0 || w >= c) continue;
					if (check[u][w]) continue;
					check[u][w] = 1; Q.push({ u, w });
				}
			} cnt++;
		}
	} if (cnt == 0) return !(cout << -1);
	
	vi out(cnt, -1);
	for (int i = 0; i < cnt; i++) {
		queue<vi> Q; Q.push({ isl[i][0], isl[i][1] });
		vector<vi> visit = v; bool sea = false;

		int idx = v[isl[i][0]][isl[i][1]];
		while (!Q.empty() && !sea) {
			int x = Q.front()[0], y = Q.front()[1]; Q.pop();
			for (auto d : d4) {
				int u = x + d[0], w = y + d[1];
				if (u < 0 || u >= r || w < 0 || w >= c) {
					sea = true; break;
				}
				if (visit[u][w] != 1000) {
					if (v[u][w] == 1000) continue;
					if (v[u][w] < idx) idx = v[u][w];
					continue;
				}
				visit[u][w] = 1001; Q.push({ u, w });
			}
		} if (!sea) out[i] = idx;
	}

	vi h(cnt, 0); int max_h = 0;
	for (int i = 0; i < cnt; i++) {
		int l = 0, j = i;
		while (out[j] != -1) {
			j = out[j]; l++;
			if (h[j] < l) h[j] = l;
			max_h = max(max_h, l);
		}
	}

	vi res(max_h + 1, 0);
	for (auto i : h) res[i] += 1;
	for (auto i : res) cout << i << " ";
	return 0;
}
{% endhighlight %}

그래프 탐색 문제다. 여러 풀이가 있겠지만, 너비 우선 탐색을 이용해봤다.<br>
먼저, 풀이의 전체적인 흐름을 파악해보자.<br>

우리가 알아야 할 것은 섬의 높이, 즉 어떤 섬 안에 들어있는 섬의 개수이다.<br>
지도를 왼쪽에서 오른쪽으로, 위에서 아래로 탐색하면서 순서대로 섬에 번호를 붙인다면,<br>
어떤 섬이 다른 섬을 포함하고 있을 때 바깥에 있는 섬이 먼저 탐색되기 때문에 분명히 그 섬은 자신을 둘러싼 섬보다 번호가 클 것이다.<br>

바로 이 점을 이용한다. 어떤 섬에서 바다를 탐색할 때 경계에 도달하지 않았다면 다른 섬 안에 있다는 뜻이 되고, 만날 수 있는 섬 중 가장 작은 번호의 섬이 자신을 둘러싼 섬이 된다. 이렇게 각 섬마다 자신을 둘러싼 섬을 찾은 후 각 섬의 높이를 계산하면 끝난다.<br><br>

정리하면 다음과 같다.
1. 지도를 탐색하며 섬에 번호를 붙인다.
2. 각 섬마다 주변 바다를 탐색하여 지도의 경계에 도달할 수 있는지 확인한다.
3. 도달할 수 없다면, 탐색 도중 만나는 섬 중 가장 작은 번호를 저장한다.
4. 섬의 높이를 계산한다.